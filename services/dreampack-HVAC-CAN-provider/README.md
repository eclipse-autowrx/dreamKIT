# dk_service_can_provider

> **Overview**
> This Docker service provides CAN bus communication based on CAN signals defined in `.dbc` files and VSS (Vehicle Signal Specification) signals. It bridges CAN bus messages with KUKSA databroker for vehicle data management.

## ğŸ“‘ Table of Contents

- [ğŸ¨ Design Phase](#-design-phase)
  - [Design Workflow](#design-workflow)
  - [Input Files (User-Designed)](#input-files-user-designed)
  - [Output Files (Auto-Generated)](#output-files-auto-generated)
  - [Signal Types](#signal-types)
  - [Generation Script](#generation-script)
  - [Example dbc_overlay.vspec](#example-dbc_overlayvspec)
- [ğŸ¯ Development Scenarios & Workflows](#-development-scenarios--workflows)
  - [ğŸ“‹ Scenario Overview](#-scenario-overview)
  - [ğŸ–¥ï¸ Scenario 1: Local Development (x86_64)](#ï¸-scenario-1-local-development-x86_64)
  - [ğŸ’» Scenario 2: ARM Development (Jetson Orin)](#-scenario-2-arm-development-jetson-orin)
  - [ğŸš€ Scenario 3: Production Deployment (k3s)](#-scenario-3-production-deployment-k3s)
  - [ğŸŒ Scenario 4: Marketplace Release](#-scenario-4-marketplace-release)
- [ğŸ› ï¸ Build Script Reference](#ï¸-build-script-reference)
- [ğŸ“Š Service Management](#-service-management)
- [ğŸ”§ Configuration Reference](#-configuration-reference)
- [ğŸ§ª Testing & Validation](#-testing--validation)
- [ğŸ” Troubleshooting](#-troubleshooting)
- [ğŸ“š File Structure](#-file-structure)
- [ğŸš€ Quick Reference](#-quick-reference)

---

## ğŸ¨ Design Phase

### Design Workflow

Before deploying the service, you need to design the VSS-to-CAN mapping and vice-versa:
Details can be found from https://github.com/eclipse-kuksa/kuksa-can-provider/blob/main/mapping/README.md

```
1. Design Input Files          2. Generate Mappings        3. Deploy Service
   (Manual)                        (Automated)                 (Runtime)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ dbc_overlay     â”‚            â”‚                 â”‚         â”‚                 â”‚
â”‚   .vspec        â”‚â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â–ºâ”‚    ./vss.sh     â”‚â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚  Docker         â”‚
â”‚ (USER DESIGN)   â”‚       â”‚    â”‚                 â”‚         â”‚  Container      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â”‚             â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚             â”œâ”€â–º vss_dbc.json
â”‚ ModelCAN.dbc    â”‚â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚   (VSS mapping)
â”‚ (USER PROVIDED) â”‚                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                     â””â”€â–º dbc_default_values.json
                                            (CAN defaults)
```

### Input Files (User-Designed)

| File | Purpose | Example |
|------|---------|---------|
| `prepare-dbc-file/mapping/vss_4.0/dbc_overlay.vspec` | Define VSS-to-CAN signal mappings | See [dbc_overlay.vspec example](#example-dbc_overlayvspec) |
| `prepare-dbc-file/ModelCAN.dbc` | CAN database with message/signal definitions | Standard DBC format |

### Output Files (Auto-Generated)

| File | Purpose | Generated By |
|------|---------|--------------|
| `prepare-dbc-file/mapping/vss_4.0/vss_dbc.json` | Runtime VSS-DBC mapping | `./vss.sh` (vspec2json.py) |
| `prepare-dbc-file/mapping/dbc_default_values.json` | Default values for all CAN signals in actuator messages | `./vss.sh` (DBC parser) |

### Signal Types

#### SENSOR (CAN â†’ VSS)
Read-only signals from CAN bus to VSS databroker.

**Use Case:** Vehicle speed sensor reading from CAN bus displayed in UI

```yaml
# dbc_overlay.vspec
Vehicle.Speed:
  type: sensor
  datatype: float
  dbc2vss:
    signal: DI_uiSpeed          # CAN signal from ModelCAN.dbc
    interval_ms: 500            # Update every 0.5 seconds
```

**Test Workflow:**
```bash
# 1. Send CAN message (ID: 0x257, bit 24-32)
cansend vcan0 257#0000000001000000
cansend vcan0 257#0000000100000000

# 2. Monitor in KUKSA
kuksa-client grpc://127.0.0.1:55555
subscribe Vehicle.Speed
# âœ“ Value updates to 256
# âœ“ Value updates to 1
```

#### ACTUATOR (VSS â†’ CAN)
Writable signals from VSS databroker to CAN bus.

**Use Case:** User toggles low beam headlights from UI, sent to CAN bus

```yaml
# dbc_overlay.vspec
Vehicle.Body.Lights.Beam.Low.IsOn:
  type: actuator
  datatype: boolean
  vss2dbc:
    signal: DAS_lowBeamRequest  # CAN signal from ModelCAN.dbc
    transform:
      mapping:
        - from: true
          to: DAS_HEADLIGHT_REQUEST_ON      # Enum value from DBC
        - from: false
          to: DAS_HEADLIGHT_REQUEST_OFF     # Enum value from DBC
```

**Test Workflow:**
```bash
# 1. Set value in KUKSA
kuksa-client grpc://127.0.0.1:55555
setTargetValue Vehicle.Body.Lights.Beam.Low.IsOn true

# 2. Monitor CAN bus
candump vcan0
# âœ“ Observe: 3E9#0100000000000000 (ID: 0x3E9)
```

### Generation Script

**Prerequisites:**
```bash
pip3 install -r requirements.txt
```

**Generate mappings:**
```bash
./vss.sh          # Run Development Workflow
./vss.sh -h       # Show detailed help
```

**What `./vss.sh` does:**

1. **Clone VSS Repository** (if not present)
   - Repository: `https://github.com/COVESA/vehicle_signal_specification`
   - Branch: `4.X`
   - Location: `dreamKIT/vehicle_signal_specification/`
   - Includes: `vss-tools` submodule

2. **Generate `vss_dbc.json`**
   - Input: `dbc_overlay.vspec` + VSS specification
   - Tool: `vspec2json.py` from vss-tools
   - Output: `prepare-dbc-file/mapping/vss_4.0/vss_dbc.json`

3. **Generate `dbc_default_values.json`**
   - Parse `dbc_overlay.vspec` for all actuator signals
   - Find CAN messages containing those signals in `ModelCAN.dbc`
   - Extract **all** signals from those CAN messages
   - Create JSON with default value `0` for each signal

**Example: HVAC Fan Speed Actuator**

Given `dbc_overlay.vspec`:
```yaml
Vehicle.Cabin.HVAC.Station.Row1.Driver.FanSpeed:
  datatype: int8
  type: actuator
  vss2dbc:
    signal: VCRIGHT_hvacBlowerSpeedRPMReq
```

And `ModelCAN.dbc`:
```dbc
BO_ 524 ID20CVCRIGHT_hvacRequest: 8 VehicleBus
 SG_ VCRIGHT_conditioningRequest : 12|1@1+ (1,0) [0|1] ""  Receiver
 SG_ VCRIGHT_hvacBlowerSpeedRPMReq : 32|10@1+ (5,0) [0|5115] "RPM"  Receiver
 SG_ VCRIGHT_hvacEvapEnabled : 11|1@1+ (1,0) [0|1] ""  Receiver
 SG_ VCRIGHT_tempEvaporator : 13|11@1+ (0.1,-40) [-40|105] "C"  Receiver
 ...
```

Generated `dbc_default_values.json`:
```json
{
  "VCRIGHT_conditioningRequest" : 0,
  "VCRIGHT_hvacBlowerSpeedRPMReq" : 0,
  "VCRIGHT_hvacEvapEnabled" : 0,
  "VCRIGHT_tempEvaporator" : 0,
  ...
}
```

> **Note:** All signals from the CAN message `ID20CVCRIGHT_hvacRequest` are included because it contains the actuator signal `VCRIGHT_hvacBlowerSpeedRPMReq`.

### Example dbc_overlay.vspec

Complete example with multiple signal types:

```yaml
# Actuator: Low Beam Headlights (boolean with enum mapping)
Vehicle.Body.Lights.Beam.Low.IsOn:
  type: actuator
  datatype: boolean
  vss2dbc:
    signal: DAS_lowBeamRequest
    transform:
      mapping:
        - from: true
          to: DAS_HEADLIGHT_REQUEST_ON
        - from: false
          to: DAS_HEADLIGHT_REQUEST_OFF

# Actuator: Hazard Lights (boolean with enum mapping)
Vehicle.Body.Lights.Hazard.IsSignaling:
  type: actuator
  datatype: boolean
  vss2dbc:
    signal: DAS_hazardLightRequest
    transform:
      mapping:
        - from: true
          to: DAS_REQUEST_HAZARDS_ON
        - from: false
          to: DAS_REQUEST_HAZARDS_OFF

# Actuator: High Beam (boolean, direct mapping)
Vehicle.Body.Lights.Beam.High.IsOn:
  type: actuator
  datatype: boolean
  vss2dbc:
    signal: DAS_highBeamRequest

# Actuator: Seat Position (integer, range 0-10)
Vehicle.Cabin.Seat.Row1.DriverSide.Position:
  datatype: int8
  type: actuator
  vss2dbc:
    signal: VCRIGHT_frontSeatTrackForward

# Actuator: HVAC Fan Speed Driver (integer, RPM)
Vehicle.Cabin.HVAC.Station.Row1.Driver.FanSpeed:
  datatype: int8
  type: actuator
  vss2dbc:
    signal: VCRIGHT_hvacBlowerSpeedRPMReq

# Actuator: HVAC Fan Speed Passenger (integer, RPM)
Vehicle.Cabin.HVAC.Station.Row1.Passenger.FanSpeed:
  datatype: int8
  type: actuator
  vss2dbc:
    signal: VCLEFT_hvacBlowerRPMTarget
```

---

## ğŸ¯ Development Scenarios & Workflows

Choose the workflow that matches your development environment and goals:

### ğŸ“‹ Scenario Overview

| Scenario | Environment | Architecture | Use Case | Workflow |
|----------|-------------|--------------|----------|----------|
| **Local Dev (x86)** | Ubuntu x86_64 | amd64 | Development & Testing | [Local Development](#-scenario-1-local-development-x86_64) |
| **Local Dev (ARM)** | Jetson Orin | arm64 | Native ARM Testing | [ARM Development](#-scenario-2-arm-development-jetson-orin) |
| **Production** | k3s Cluster | arm64 | Production Deployment | [Production Deployment](#-scenario-3-production-deployment-k3s) |
| **Marketplace** | Public Release | arm64 | Public Distribution | [Marketplace Release](#-scenario-4-marketplace-release) |

---

## ğŸ–¥ï¸ Scenario 1: Local Development (x86_64)

**When to use:** Developing and testing on Ubuntu x86_64 with virtual CAN

### Prerequisites
- Ubuntu x86_64 system
- Docker installed
- KUKSA databroker running on localhost:55555
- CAN utilities: `sudo apt install can-utils`

### Workflow
```bash
# 1. Build for current architecture (auto-detected)
./build.sh local

# 2. Start development environment
./start.sh local

# 3. Test the service
kuksa-client grpc://127.0.0.1:55555
# Test commands:
setTargetValue Vehicle.Body.Lights.Beam.Low.IsOn true

# 4. Monitor CAN traffic
candump vcan0

# 5. Stop when done
./stop.sh local
```

### Configuration
- **KUKSA Address:** `localhost:55555`
- **CAN Interface:** `vcan0` (virtual)
- **VSS Mapping:** `mapping/vss_4.0/vss_dbc.json`
- **Architecture:** Auto-detected (amd64)

---

## ğŸ’» Scenario 2: ARM Development (Jetson Orin)

**When to use:** Testing directly on ARM64 hardware before production deployment

### Prerequisites
- Jetson Orin with Ubuntu ARM64
- Docker installed
- KUKSA databroker running
- Physical CAN interface or virtual CAN

### Workflow
```bash
# 1. Build for current architecture (ARM64 auto-detected)
./build.sh local

# 2. Start with virtual CAN for testing
./start.sh local

# OR start with physical CAN
docker run -d -it --name dk_service_can_provider --net=host --privileged \
  -e KUKSA_ADDRESS=localhost \
  -e CAN_PORT=can1 \
  -e MAPPING_FILE=mapping/vss_4.0/vss_dbc.json \
  dk_service_can_provider:latest

# 3. Test the service
kuksa-client grpc://127.0.0.1:55555

# 4. Monitor CAN traffic
candump can1  # or vcan0

# 5. Stop when done
./stop.sh local
```

### Configuration
- **KUKSA Address:** `localhost:55555`
- **CAN Interface:** `can1` (physical) or `vcan0` (virtual)
- **VSS Mapping:** `mapping/vss_4.0/vss_dbc.json`
- **Architecture:** ARM64 (auto-detected)

---

## ğŸš€ Scenario 3: Production Deployment (k3s)

**When to use:** Deploying to production k3s cluster with distributed nodes

### Prerequisites
- k3s cluster running
- Jetson Orin as master (192.168.56.48)
- S32G as agent node with CAN interface
- kubectl configured

### Option A: Using Pre-built Image (Recommended)
```bash
# 1. Build and push to GitHub Container Registry
./build.sh prod --push

# 2. Deploy to k3s (pulls from GHCR)
kubectl apply -f manifests/mirror-remote.yaml    # Pull image to local registry
kubectl apply -f manifests/deployment.yaml # Deploy service
kubectl apply -f manifests/service.yaml   # Create service

# 3. Monitor deployment
kubectl get pods -l app=dk-service-can-provider
kubectl logs -f -l app=dk-service-can-provider

# 4. Test the service
kuksa-client grpc://192.168.56.48:55555
```

### Option B: Using Local Image Import
```bash
# 1. Build for production
./build.sh prod

# 2. Import to k3s and deploy
./start.sh prod --import

# 3. Monitor deployment
./start.sh prod --status
```

### Option C: Manual Image Import (Your Method)
```bash
# 1. Build production image
./build.sh prod

# 2. Save and import image
docker save dk_service_can_provider:latest > dk_service_can_provider.tar
sudo k3s ctr images import dk_service_can_provider.tar
rm dk_service_can_provider.tar

# 3. Deploy manifests
kubectl apply -f manifests/mirror-local.yaml
kubectl apply -f manifests/deployment.yaml
```

### Configuration
- **KUKSA Address:** `192.168.56.48:55555`
- **CAN Interface:** `can1` (physical on S32G)
- **VSS Mapping:** `mapping/vss_4.0/vss_dbc.json`
- **Architecture:** ARM64
- **Node Assignment:** Service runs on `vip` node

---

## ğŸŒ Scenario 4: Marketplace Release

**When to use:** Publishing to Digital Auto Marketplace for public distribution

### Prerequisites
- Tested and validated service
- GitHub Container Registry access
- Digital Auto Marketplace account

### Workflow
```bash
# 1. Build and test locally (ARM64)
./build.sh local  # On Jetson Orin

# 2. Build and push production image
./build.sh prod v1.0.0 --push

# 3. Verify image is public
docker pull ghcr.io/eclipse-autowrx/dk_service_can_provider:v1.0.0

# 4. Submit to marketplace with template
```

### Marketplace Template
```json
{
  "Target": "vip",
  "Platform": "linux/arm64",
  "DockerImageURL": "ghcr.io/eclipse-autowrx/dk_service_can_provider:latest",
  "RuntimeCfg": {
    "CAN_PORT": "can1",
    "MAPPING_FILE": "mapping/vss_4.0/vss_dbc.json",
    "KUKSA_ADDRESS": "192.168.56.48"
  }
}
```

### Configuration
- **Public Image:** `ghcr.io/eclipse-autowrx/dk_service_can_provider:latest`
- **Target Node:** `vip` (agent node with CAN access)
- **Platform:** `linux/arm64`
- **Runtime Config:** Production settings

---

## ğŸ› ï¸ Build Script Reference

### Commands
```bash
# Auto-detect architecture and build for local development
./build.sh local [version]

# Build for production (ARM64) deployment
./build.sh prod [version] [--push]

# Build for both environments
./build.sh both [version]
```

### Architecture Detection
- **x86_64 â†’ linux/amd64** (Ubuntu development)
- **aarch64/arm64 â†’ linux/arm64** (Jetson Orin/Production)

### Examples
```bash
./build.sh local              # Current arch, latest tag
./build.sh local v1.0.0       # Current arch, specific version
./build.sh prod               # ARM64, latest tag
./build.sh prod v1.0.0 --push # ARM64, push to GHCR
./build.sh both               # Both architectures
```

---

## ğŸ“Š Service Management

### Start Service
```bash
./start.sh local              # Local development
./start.sh prod               # Production deployment
./start.sh prod --import      # Import image and deploy
./start.sh [env] --status     # Check status
```

### Stop Service
```bash
./stop.sh local               # Stop local container
./stop.sh prod                # Stop k3s deployment
./stop.sh [env] --cleanup     # Stop and cleanup
./stop.sh [env] --force       # Force stop
```

### Monitor Service
```bash
# Local
docker logs -f dk_service_can_provider
candump vcan0

# Production
kubectl logs -f -l app=dk-service-can-provider
kubectl get pods -l app=dk-service-can-provider
```

---

## ğŸ”§ Configuration Reference

### Environment Variables

| Variable | Local | Production | Description |
|----------|-------|------------|-------------|
| `KUKSA_ADDRESS` | `localhost` | `192.168.56.48` | KUKSA databroker address |
| `CAN_PORT` | `vcan0` | `can1` | CAN interface name |
| `MAPPING_FILE` | `mapping/vss_3.0/vss_dbc.json` | `mapping/vss_4.0/vss_dbc.json` | VSS mapping file |
| `LOG_LEVEL` | `INFO` | `INFO` | Logging verbosity |
| `DBC_FILE` | `ModelCAN.dbc` | `ModelCAN.dbc` | DBC definition file |

### Network Architecture

```
Development (Local):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Developer     â”‚    â”‚   Docker     â”‚    â”‚   KUKSA         â”‚
â”‚   Machine       â”‚â—„â”€â”€â–ºâ”‚   Container  â”‚â—„â”€â”€â–ºâ”‚   Databroker    â”‚
â”‚   (vcan0)       â”‚    â”‚              â”‚    â”‚   (localhost)   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Production (k3s):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   S32G          â”‚    â”‚   k3s Pod    â”‚    â”‚   Jetson Orin   â”‚
â”‚   (can0/can1)   â”‚â—„â”€â”€â–ºâ”‚   (vip node) â”‚â—„â”€â”€â–ºâ”‚   KUKSA Server  â”‚
â”‚                 â”‚    â”‚              â”‚    â”‚   (192.168.56.48)â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ§ª Testing & Validation

> **Note:** For detailed signal test workflows, see the [Design Phase](#-design-phase) section.

### Quick Test Commands

**Connect to KUKSA:**
```bash
# Local development
kuksa-client grpc://127.0.0.1:55555

# Production (k3s cluster)
kuksa-client grpc://192.168.56.48:55555
```

**Test Actuators (VSS â†’ CAN):**
```bash
# Light controls
setTargetValue Vehicle.Body.Lights.Beam.Low.IsOn true
setTargetValue Vehicle.Body.Lights.Beam.High.IsOn false
setTargetValue Vehicle.Body.Lights.Hazard.IsSignaling true

# Seat position (range: 0-10)
setTargetValue Vehicle.Cabin.Seat.Row1.DriverSide.Position 5

# HVAC fan speed
setTargetValue Vehicle.Cabin.HVAC.Station.Row1.Driver.FanSpeed 75
setTargetValue Vehicle.Cabin.HVAC.Station.Row1.Passenger.FanSpeed 50
```

**Test Sensors (CAN â†’ VSS):**
```bash
# Subscribe to vehicle speed
subscribe Vehicle.Speed

# In another terminal, send CAN message
cansend vcan0 257#0000000001000000
```

**Monitor CAN Bus:**
```bash
# Monitor all CAN traffic
candump vcan0        # Local development
candump can1         # Production (physical CAN)

# Monitor specific message
candump vcan0,3E9:7FF
```

---

## ğŸ” Troubleshooting

### Common Issues

#### 1. Architecture Mismatch
```bash
# Check current architecture
uname -m

# Rebuild for correct architecture
./build.sh local
```

#### 2. CAN Interface Issues
```bash
# Check CAN interface
ip link show can1        # Physical
ip link show vcan0       # Virtual

# Create virtual CAN
sudo modprobe vcan
sudo ip link add dev vcan0 type vcan
sudo ip link set up vcan0
```

#### 3. KUKSA Connection Issues
```bash
# Test KUKSA connectivity
telnet 192.168.56.48 55555  # Production
telnet localhost 55555      # Local

# Check KUKSA logs
docker logs sdv-runtime
```

#### 4. k3s Deployment Issues
```bash
# Check k3s status
sudo systemctl status k3s

# Check node status
kubectl get nodes

# Check pod logs
kubectl logs -l app=dk-service-can-provider

# Check image import
sudo k3s ctr images ls | grep dk_service_can_provider
```

#### 5. Mirror Job Issues
```bash
# Check mirror job logs
kubectl logs job/mirror-dk-service-can-provider

# Manually verify image
sudo k3s ctr images ls | grep localhost:5000/dk_service_can_provider
```

---

## ğŸ“š File Structure

```
dk_service_can_provider/
â”œâ”€â”€ README.md                             # This file
â”œâ”€â”€ DEPLOYMENT.md                         # Detailed deployment guide
â”œâ”€â”€ Dockerfile                            # Container definition
â”œâ”€â”€ requirements.txt                      # Python dependencies for vss.sh
â”‚
â”œâ”€â”€ Design Phase Scripts
â”œâ”€â”€ vss.sh                                # VSS mapping generation script
â”‚
â”œâ”€â”€ Deployment Scripts
â”œâ”€â”€ build.sh                              # Build Docker images
â”œâ”€â”€ start.sh                              # Start service (local/prod)
â”œâ”€â”€ stop.sh                               # Stop service (local/prod)
â”‚
â”œâ”€â”€ Design Input Files (User-Designed)
â”œâ”€â”€ prepare-dbc-file/
â”‚   â”œâ”€â”€ ModelCAN.dbc                      # INPUT: CAN database (user-provided)
â”‚   â”œâ”€â”€ mapping/
â”‚   â”‚   â”œâ”€â”€ vss_4.0/
â”‚   â”‚   â”‚   â””â”€â”€ dbc_overlay.vspec         # INPUT: VSS-to-CAN mapping (user-designed)
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ Design Output Files (Auto-Generated)
â”‚   â”‚   â”œâ”€â”€ vss_dbc.json                  # OUTPUT: Runtime VSS-DBC mapping
â”‚   â”‚   â””â”€â”€ dbc_default_values.json       # OUTPUT: Default CAN signal values
â”‚   â”‚
â”‚   â””â”€â”€ createvcan.sh                     # Virtual CAN setup utility
â”‚
â”œâ”€â”€ Runtime Configuration
â”œâ”€â”€ mapping/                              # VSS mapping files for runtime
â”‚   â”œâ”€â”€ vss_3.0/                         # VSS 3.x mappings (alternative)
â”‚   â””â”€â”€ vss_4.0/                         # VSS 4.x mappings (default)
â”œâ”€â”€ config/
â”‚   â””â”€â”€ dbc_feeder.ini                    # DBC feeder configuration
â”‚
â””â”€â”€ Kubernetes Deployment
    â””â”€â”€ manifests/
        â”œâ”€â”€ mirror-local.yaml             # Local image mirror job
        â”œâ”€â”€ mirror-remote.yaml            # Remote image mirror job (GHCR)
        â”œâ”€â”€ deployment.yaml               # k3s deployment
        â””â”€â”€ service.yaml                  # k3s service
```

### File Categories

| Category | Files | Purpose |
|----------|-------|---------|
| **Design Inputs** | `dbc_overlay.vspec`, `ModelCAN.dbc` | User designs VSS-CAN mappings |
| **Design Outputs** | `vss_dbc.json`, `dbc_default_values.json` | Auto-generated by `./vss.sh` |
| **Runtime Config** | `mapping/`, `config/` | Used by Docker container at runtime |
| **Deployment** | `build.sh`, `start.sh`, `stop.sh`, `manifests/` | Build and deploy service |

---

## ğŸš€ Quick Reference

### Development Workflow

```bash
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Phase 1: Design VSS-to-CAN Mapping
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# 1. Design your dbc_overlay.vspec file
vim prepare-dbc-file/mapping/vss_4.0/dbc_overlay.vspec

# 2. Generate mapping files
pip3 install -r requirements.txt
./vss.sh

# 3. Verify generated files
cat prepare-dbc-file/mapping/vss_4.0/vss_dbc.json
cat prepare-dbc-file/mapping/dbc_default_values.json

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Phase 2: Development & Testing
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# 4. Build for your architecture
./build.sh local              # Auto-detect (x86_64 or ARM64)

# 5. Start service
./start.sh local              # Local development

# 6. Test signals
kuksa-client grpc://127.0.0.1:55555
setTargetValue Vehicle.Body.Lights.Beam.Low.IsOn true

# 7. Monitor CAN bus
candump vcan0

# 8. Stop when done
./stop.sh local

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Phase 3: Production Deployment
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# 9. Build for production (ARM64)
./build.sh prod

# 10. Deploy to k3s
./start.sh prod --import      # Import and deploy

# 11. Monitor in production
kubectl logs -f -l app=dk-service-can-provider
candump can1

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Phase 4: Marketplace Release
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# 12. Create versioned release
./build.sh prod v1.0.0 --push

# 13. Submit to Digital Auto Marketplace
# Use GHCR URL: ghcr.io/eclipse-autowrx/dk_service_can_provider:v1.0.0
```

### Essential Commands

| Task | Command |
|------|---------|
| **Design** | `./vss.sh` |
| **Build Local** | `./build.sh local` |
| **Build Production** | `./build.sh prod` |
| **Test Local** | `./start.sh local` |
| **Deploy Production** | `./start.sh prod --import` |
| **Monitor Logs** | `docker logs -f dk_service_can_provider` (local)<br>`kubectl logs -f -l app=dk-service-can-provider` (prod) |
| **Test Signals** | `kuksa-client grpc://127.0.0.1:55555` |
| **Monitor CAN** | `candump vcan0` (local)<br>`candump can1` (prod) |

---

This comprehensive guide ensures you can successfully design, develop, test, and deploy the dk_service_can_provider service across all scenarios and environments.